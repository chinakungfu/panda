<?php/** * 最后修改时间：2008-04-17 16：45 * 修改内容：修改函数handleRequest的模板的调用方式 *  * ajax的服务类，是所有ajax的服务端调用的入口函数 * 通过该服务类可以调用服务端的 * 1、模板文件 * 2、php函数 * 3、php类方法 *//** * javascript的json的对象的转换类 * *//** * Marker constant for JSON::decode(), used to flag stack state */define('JSON_SLICE',   1);/** * Marker constant for JSON::decode(), used to flag stack state */define('JSON_IN_STR',  2);/** * Marker constant for JSON::decode(), used to flag stack state */define('JSON_IN_ARR',  4);/** * Marker constant for JSON::decode(), used to flag stack state */define('JSON_IN_OBJ',  8);/** * Marker constant for JSON::decode(), used to flag stack state */define('JSON_IN_CMT', 16);/** * Behavior switch for JSON::decode() */define('JSON_LOOSE_TYPE', 10);/** * Behavior switch for JSON::decode() *//** * Behavior switch for JSON::decode() */define('JSON_STRICT_TYPE', 11);import('core.tpl.TplRun');import('core.tpl.TplTemplate');class AjaxService{	const version = '0.9'; //ajax版本	const MethodOption        = 'method';	const HandlerOption       = 'handler';	const DebugOption         = 'debug';	const DisplayErrorsOption = 'errors';	const PrependOption       = 'prepend';	const EncodeOption        = 'encode';	const MethodPost = 'post';	const MethodGet  = 'get';	public  $request;//请求对象	protected $options=array();//ajax选项	public function getOption( $option )	{		return $this->options[ $option ];	}	public function getOptions()	{		return $this->options;	}	public function setOptions($options)	{		$this->options=$options;	}	/** * 根据服务类id来取得该服务类对应的ajax的配置 * * @param unknown_type $serviceId * @param unknown_type $funcId */	function getAjaxByService($ajaxconfig,$actionId,$methodId)	{				try		{			$currentservice=null;//当前服务类			if (array_key_exists($actionId,$ajaxconfig))			{				$currentservice=$ajaxconfig[$actionId];				if (array_key_exists($methodId,$currentservice))				{					return $currentservice[$methodId];				}				else				{					return null;				}			}			else			{				return null;			}		}		catch (Exception $e)		{			throw $e;		}	}	/** * Enter description here... * * @param unknown_type $type * @param unknown_type $serviceId * @param unknown_type $funcId */	function getAjaxConfig($actionId,$methodId)	{		/*		if (file_exists('testconfig.php'))		{		require_once('testconfig.php');		}		else		{		die('file not exists'.realpath("./phpwork/test/testconfig.php"));		}		*/		return $this->getAjaxByService($GLOBALS['currentApp']["ajaxConfig"],$actionId,$methodId);	}	/**	 * 检测方法是否存在	 *	 * @param unknown_type $function	 */	protected function validFunction( $function )	{		if ( !function_exists( $function ) )		{			throw new AjaxException( "Function $function does not exist" );		}	}	//检测类的方法是否存在	protected function validClassAndMethod( $class, $method )	{		try		{			$reflectionClass  = new ReflectionClass( $class );			$reflectionMethod = $reflectionClass->getMethod( $method );			if ( !$reflectionMethod->isStatic() && ( !$reflectionClass->isInstantiable() || $reflectionClass->isAbstract() ) )			{				throw new AjaxException( "Class $class is not instantiable" );			}			if ( !$reflectionMethod->isPublic() )			{				throw new AjaxException( "Method $class::$method is not public" );			}			return $reflectionMethod->isStatic();		}		catch( ReflectionException $e )		{			throw new AjaxException( $e->getMessage() );		}	}	/**	 * 类的构造方法	 *	 * @param unknown_type $options	 */	public function __construct( $options = null )	{		if (is_array($options))		{			$this->options=$options;		}		else		{			// Use default values			$this->options[ AjaxService::MethodOption ]        = AjaxService::MethodPost;			//$this->options[ AjaxService::MethodOption ]        = AjaxService::MethodGet;			$this->options[ AjaxService::HandlerOption ]       = '';			$this->options[ AjaxService::DebugOption ]         = false;			$this->options[ AjaxService::DisplayErrorsOption ] = true;			$this->options[ AjaxService::PrependOption ]       = 'call_';			$this->options[ AjaxService::EncodeOption ]        = false;		}		/**		 * 设置界面的参数到$request数组里面		 */		/*if ( $this->getOption( AjaxService::MethodOption ) == AjaxService::MethodGet)		{			$this->request =& $_GET;		}		else		{			$this->request =& $_POST;		}*/		$this->request = $_REQUEST;	}	/**	 * 请求调用服务端程序的类型	 * tpl-调用模板	 * func-调用的php函数	 * cls-调用服务端类的方法	 * @var unknown_type	 */	/**	 * 判断请求是否是ajax请求	 *	 */	public function isRequest()	{		return ( isset( $this->request['ajax']) );	}	/**       * Handle Ajax request       *       * Unpack JSON encoded Ajax request and call the appropriate function or       * method.       *       * @return JSON encoded AjaxResponse object      **/	public function handleRequest()	{		//$json     = new Json();		$response = new AjaxResponse();		//$request  = $json->decode( stripslashes( $this->request[ 'ajax' ] ) );		if(array_key_exists('phprpc_args',$this->request))//判断是否用PHPPRC调用		{			$phprpc_args = base64_decode($this->request['phprpc_args']);			$phprpc_args = unserialize($phprpc_args);//取得PHPRPC传过来的参数			$request  = unserialize(stripslashes( substr($phprpc_args[0],5) ));//取出PHPRPC参数是的AJAX字符串赋给$request			$phprpc_callback = base64_decode($this->request['phprpc_callback']);//取出PHPRPC的回调函数		}else {//调用系统本身的AJAX			$request  = unserialize(stripslashes( $this->request[ 'ajax' ] ) );		}		$currentservice=null;		//首先检测文件是否存在		try {			$currentservice=$this->getAjaxConfig($request['serviceid'],$request['methodid']);			//print_r($currentservice);			if ($currentservice!=null)			{				if (file_exists($currentservice['file']))				{					//require_once($currentservice['file']);				}				else				{					$response->setErrorCode( 2 );					$response->setErrorMessage('call file:'.$currentservice['file'].' not exists exception');					$response->setServerVersion( AjaxService::version );					//header( 'Content-Type', 'text/json' );					//return $json->encode( $response );					return unserialize($response);				}			}			else			{				$response->setErrorCode( 2 );				$response->setErrorMessage('not find call file exception');				$response->setServerVersion( AjaxService::version );				//header( 'Content-Type', 'text/json' );				//return $json->encode( $response );				return unserialize($response);			}			// 调用类方法			if ($currentservice['type']=='cls')			{				try				{					if ( $this->validClassAndMethod( $currentservice['className'], $currentservice['func']) )					{						$response->setResponse( call_user_func_array( array($currentservice['classname'], $currentservice['func']), $request->params ),						$this->getOption( AjaxService::EncodeOption));					}					else					{						$obj = new $currentservice['className'];						$response->setResponse( call_user_func_array( array( $obj, $currentservice['func'] ), $request->params ),						$this->getOption( AjaxService::EncodeOption ) );					}					$response->setErrorCode( 0 );				}				catch( AjaxException $e )				{					$response->setErrorCode( 2 );					$response->setErrorMessage( $e->getMessage() );					$response->setServerVersion( AjaxService::version );					//header( 'Content-Type', 'text/json' );					//return $json->encode( $response );					return unserialize($response);				}			}			// Call function			else if ($currentservice['type']=='func')			{				$response->setResponse(call_user_func_array( $currentservice['func'], $request['params'] ),				$this->getOption( AjaxService::EncodeOption ) );				$response->setErrorCode( 0 );			}			//调用模板文件						else if ($currentservice['type']='tpl')			{				//预处理模板的参数问题				$currentparams=array();				if ($currentservice['params']!=null)				{					if (strpos($currentservice['params'],','))//有多个参数					{						$datas=explode(',',$currentservice['params']);						foreach ($datas as $key=>$var)						{							if (array_key_exists($key,$request['params']))							{								$currentparams[$var]=$request['params'][$key];							}													}					}					else //只有一个参数					{						if ($currentservice['params']!="")						{							if (array_key_exists('0',$request['params']))							{								$currentparams[$currentservice['params']]=$request['params']['0'];							}						}					}									}				$tpl=new TplRun();				$tpl->assign($currentparams);				if($request->callmode=='display')//call_tpl的调用模式不display				{					$response->setResponse($tpl->runTplReturn($currentservice['file']),$this->getOption( AjaxService::EncodeOption ));				}else {//call_tpl的调用模式不return					$response->setResponse($tpl->callTplWithReturn($currentservice['file']),$this->getOption( AjaxService::EncodeOption ));				}				unset($tpl);				$response->setErrorCode( 0 );			}			else			{				$response->setErrorCode( 3 );				$response->setErrorMessage( 'Unknown AJAX request!' );				$response->setServerVersion( AjaxService::version );				//header( 'Content-Type', 'text/json' );				//return $json->encode( $response );				return serialize($response);			}		}		catch (AjaxException $ex)		{			$response->setErrorCode( 2 );			$response->setErrorMessage($ex->getMessage());			$response->setServerVersion( AjaxService::version );			//header( 'Content-Type', 'text/json' );			//return $json->encode( $response );			return serialize($response);		}		$response->setServerVersion( AjaxService::version );		//header( 'Content-Type', 'text/json' );		//return $json->encode( $response );		//print_r($response);		//return serialize($response);//序列化返回值		if($this->request['pattern'])//判断是远程调用还是本地调用		{			$response = serialize($response->response);//序列化返回值			$flag = true;			$response = addJsSlashes($response, $flag);			$str = "phprpc_result=\"$response\";\r\n";			$str .= "phprpc_errno=\"\";\r\n";			$str .= "phprpc_errstr=\"\";\r\n";			$str .= "phprpc_output=\"\";\r\n";			$str .= "phprpc_output=\"\";\r\n" .$phprpc_callback;			return $str;		}else 		{			return serialize($response);//序列化返回值		}	}}function addJsSlashes($str, $flag) {if ($flag) {    $str = addcslashes($str, "\0..\006\010..\012\014..\037\042\047\134\177..\377");}else {    $str = addcslashes($str, "\0..\006\010..\012\014..\037\042\047\134");}return str_replace(array(chr(7), chr(11)), array('\007', '\013'), $str);}/** * ajax处理结果的存放类 */class AjaxResponse{	public function setErrorCode( $errorCode )	{		$this->errorCode = $errorCode;	}	public function getErrorCode()	{		return $this->errorCode;	}	public function setErrorMessage( $errorMessage )	{		$this->errorMessage = $errorMessage;	}	public function getErrorMessage()	{		return $this->errorMessage;	}	public function setServerVersion( $serverVersion )	{		$this->serverVersion = $serverVersion;	}	public function getServerVersion()	{		return $this->serverVersion;	}	public function setResponse( $response, $encode = false )	{		if ( $encode )		{			$this->encodeResponse( $response );		}		$this->response = $response;	}	public function getResponse()	{		return $this->response;	}	/* These class members are public so that they can be encoded	by the JSON library. Do not alter them directly, instead use	the getter and setter methods above!! */	/**       * Contains an error code or 0 if no error occured      **/	public $errorCode = 0;	/**       * Contains a descriptive error message if errorCode != 0      **/	public $errorMessage;	/**       * Contains version of the server side AJASON library      **/	public $serverVersion;	/**       * Contains the return value from the function or method which has       * been called by the AjaxServer class on request      **/	public $response;	private function encodeResponse( &$response )	{		if ( is_string( $response ) )		{			$response = utf8_encode( $response );		}		else if ( is_array( $response ) )		{			// Encode all items of the array			foreach ( $response as &$item )			{				$this->encodeResponse( $item );			}		}		else if ( is_object( $response ) )		{			/* We can only encode public members of an object			but there is no need to convert more, because only			these public members will be encoded by JSON. */			foreach ( get_object_vars( $response ) as $key => $item )			{				$this->encodeResponse( $item );				eval( "\$response->$key = \$item;" );			}		}	}}/** * ajax的异常处理类 * */class AjaxException extends Exception {};/** * ajax父类的调用总入库$ajax = new AjaxService();$json=new Json();if ( $ajax->isRequest() ){	//处理权限验证问题	echo $ajax->handleRequest();	exit();} *//** * Converts to and from JSON format. * * @category    * @package     * @author     Michal Migurski <mike-json@teczno.com> * @author     Matt Knapp <mdknapp[at]gmail[dot]com> * @author     Brett Stimmerman <brettstimmerman[at]gmail[dot]com> * @copyright  2005 Michal Migurski * @license    http://www.php.net/license/3_0.txt  PHP License 3.0 * @version     * @link        * @see         * @since       * @deprecated  */class Json{	/**    * constructs a new JSON instance    *    * @param    int     $use    object behavior: when encoding or decoding,    *                           be loose or strict about object/array usage    *    *                           possible values:    *                              JSON_STRICT_TYPE - strict typing, default    *                                                 "{...}" syntax creates objects in decode.    *                               JSON_LOOSE_TYPE - loose typing    *                                                 "{...}" syntax creates associative arrays in decode.    */	function JSON($use=JSON_STRICT_TYPE)	{		$this->use = $use;	}	/**    * encodes an arbitrary variable into JSON format    *    * @param    mixed   $var    any number, boolean, string, array, or object to be encoded.    *                           see argument 1 to JSON() above for array-parsing behavior.    *                           if var is a strng, note that encode() always expects it    *                           to be in ASCII or UTF-8 format!    *    * @return   string  JSON string representation of input var    * @access   public    */	function encode($var)	{		switch (gettype($var)) {			case 'boolean':				return $var ? 'true' : 'false';			case 'NULL':				return 'null';			case 'integer':				return sprintf('%d', $var);			case 'double':			case 'float':				return sprintf('%f', $var);			case 'string':				// STRINGS ARE EXPECTED TO BE IN ASCII OR UTF-8 FORMAT				$ascii = '';				$strlen_var = strlen($var);				/*				* Iterate over every character in the string,				* escaping with a slash or encoding to UTF-8 where necessary				*/				for ($c = 0; $c < $strlen_var; ++$c) {					$ord_var_c = ord($var{$c});					switch ($ord_var_c) {						case 0x08:  $ascii .= '\b';  break;						case 0x09:  $ascii .= '\t';  break;						case 0x0A:  $ascii .= '\n';  break;						case 0x0C:  $ascii .= '\f';  break;						case 0x0D:  $ascii .= '\r';  break;						case 0x22:						case 0x2F:						case 0x5C:							// double quote, slash, slosh							$ascii .= '\\'.$var{$c};							break;						case (($ord_var_c >= 0x20) && ($ord_var_c <= 0x7F)):							// characters U-00000000 - U-0000007F (same as ASCII)							$ascii .= $var{$c};							break;						case (($ord_var_c & 0xE0) == 0xC0):							// characters U-00000080 - U-000007FF, mask 110XXXXX							// see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8							$char = pack('C*', $ord_var_c, ord($var{$c+1}));							$c+=1;							$utf16 = mb_convert_encoding($char, 'UTF-16', 'UTF-8');							$ascii .= sprintf('\u%04s', bin2hex($utf16));							break;						case (($ord_var_c & 0xF0) == 0xE0):							// characters U-00000800 - U-0000FFFF, mask 1110XXXX							// see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8							$char = pack('C*', $ord_var_c,							ord($var{$c+1}),							ord($var{$c+2}));							$c+=2;							$utf16 = mb_convert_encoding($char, 'UTF-16', 'UTF-8');							$ascii .= sprintf('\u%04s', bin2hex($utf16));							break;						case (($ord_var_c & 0xF8) == 0xF0):							// characters U-00010000 - U-001FFFFF, mask 11110XXX							// see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8							$char = pack('C*', $ord_var_c,							ord($var{$c+1}),							ord($var{$c+2}),							ord($var{$c+3}));							$c+=3;							$utf16 = mb_convert_encoding($char, 'UTF-16', 'UTF-8');							$ascii .= sprintf('\u%04s', bin2hex($utf16));							break;						case (($ord_var_c & 0xFC) == 0xF8):							// characters U-00200000 - U-03FFFFFF, mask 111110XX							// see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8							$char = pack('C*', $ord_var_c,							ord($var{$c+1}),							ord($var{$c+2}),							ord($var{$c+3}),							ord($var{$c+4}));							$c+=4;							$utf16 = mb_convert_encoding($char, 'UTF-16', 'UTF-8');							$ascii .= sprintf('\u%04s', bin2hex($utf16));							break;						case (($ord_var_c & 0xFE) == 0xFC):							// characters U-04000000 - U-7FFFFFFF, mask 1111110X							// see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8							$char = pack('C*', $ord_var_c,							ord($var{$c+1}),							ord($var{$c+2}),							ord($var{$c+3}),							ord($var{$c+4}),							ord($var{$c+5}));							$c+=5;							$utf16 = mb_convert_encoding($char, 'UTF-16', 'UTF-8');							$ascii .= sprintf('\u%04s', bin2hex($utf16));							break;					}				}				return '"'.$ascii.'"';			case 'array':				/*				* As per JSON spec if any array key is not an integer				* we must treat the the whole array as an object. We				* also try to catch a sparsely populated associative				* array with numeric keys here because some JS engines				* will create an array with empty indexes up to				* max_index which can cause memory issues and because				* the keys, which may be relevant, will be remapped				* otherwise.				*				* As per the ECMA and JSON specification an object may				* have any string as a property. Unfortunately due to				* a hole in the ECMA specification if the key is a				* ECMA reserved word or starts with a digit the				* parameter is only accessible using ECMAScript's				* bracket notation.				*/				// treat as a JSON object				if (is_array($var) && count($var) && (array_keys($var) !== range(0, sizeof($var) - 1))) {					return sprintf('{%s}', join(',', array_map(array($this, 'name_value'),					array_keys($var),					array_values($var))));				}				// treat it like a regular array				return sprintf('[%s]', join(',', array_map(array($this, 'encode'), $var)));			case 'object':				$vars = get_object_vars($var);				return sprintf('{%s}', join(',', array_map(array($this, 'name_value'),				array_keys($vars),				array_values($vars))));			default:				return '';		}	}	/**    * encodes an arbitrary variable into JSON format, alias for encode()    */	function enc($var)	{		return $this->encode($var);	}	/** function name_value    * array-walking function for use in generating JSON-formatted name-value pairs    *    * @param    string  $name   name of key to use    * @param    mixed   $value  reference to an array element to be encoded    *    * @return   string  JSON-formatted name-value pair, like '"name":value'    * @access   private    */	function name_value($name, $value)	{		return (sprintf("%s:%s", $this->encode(strval($name)), $this->encode($value)));	}	/**    * reduce a string by removing leading and trailing comments and whitespace    *    * @param    $str    string      string value to strip of comments and whitespace    *    * @return   string  string value stripped of comments and whitespace    * @access   private    */	function reduce_string($str)	{		$str = preg_replace(array(		// eliminate single line comments in '// ...' form		'#^\s*//(.+)$#m',		// eliminate multi-line comments in '/* ... */' form, at start of string		'#^\s*/\*(.+)\*/#Us',		// eliminate multi-line comments in '/* ... */' form, at end of string		'#/\*(.+)\*/\s*$#Us'		), '', $str);		// eliminate extraneous space		return trim($str);	}	/**    * decodes a JSON string into appropriate variable    *    * @param    string  $str    JSON-formatted string    *    * @return   mixed   number, boolean, string, array, or object    *                   corresponding to given JSON input string.    *                   See argument 1 to JSON() above for object-output behavior.    *                   Note that decode() always returns strings    *                   in ASCII or UTF-8 format!    * @access   public    */	function decode($str)	{		$str = $this->reduce_string($str);		switch (strtolower($str)) {			case 'true':				return true;			case 'false':				return false;			case 'null':				return null;			default:				if (is_numeric($str)) {					// Lookie-loo, it's a number					// This would work on its own, but I'm trying to be					// good about returning integers where appropriate:					// return (float)$str;					// Return float or int, as appropriate					return ((float)$str == (integer)$str)					? (integer)$str					: (float)$str;				} elseif (preg_match('/^("|\').+("|\')$/s', $str, $m) && $m[1] == $m[2]) {					// STRINGS RETURNED IN UTF-8 FORMAT					$delim = substr($str, 0, 1);					$chrs = substr($str, 1, -1);					$utf8 = '';					$strlen_chrs = strlen($chrs);					for ($c = 0; $c < $strlen_chrs; ++$c) {						$substr_chrs_c_2 = substr($chrs, $c, 2);						$ord_chrs_c = ord($chrs{$c});						switch ($substr_chrs_c_2) {							case '\b':  $utf8 .= chr(0x08);  $c+=1;  break;							case '\t':  $utf8 .= chr(0x09);  $c+=1;  break;							case '\n':  $utf8 .= chr(0x0A);  $c+=1;  break;							case '\f':  $utf8 .= chr(0x0C);  $c+=1;  break;							case '\r':  $utf8 .= chr(0x0D);  $c+=1;  break;							case '\\"':							case '\\\'':							case '\\\\':							case '\\/':								if (($delim == '"' && $substr_chrs_c_2 != '\\\'') ||								($delim == "'" && $substr_chrs_c_2 != '\\"')) {									$utf8 .= $chrs{++$c};								}								break;							default:								if (preg_match('/\\\u[0-9A-F]{4}/i', substr($chrs, $c, 6))) {									// single, escaped unicode character									$utf16 = chr(hexdec(substr($chrs, ($c+2), 2)))									. chr(hexdec(substr($chrs, ($c+4), 2)));									$utf8 .= mb_convert_encoding($utf16, 'UTF-8', 'UTF-16');									$c+=5;								} elseif(($ord_chrs_c >= 0x20) && ($ord_chrs_c <= 0x7F)) {									$utf8 .= $chrs{$c};								} elseif(($ord_chrs_c & 0xE0) == 0xC0) {									// characters U-00000080 - U-000007FF, mask 110XXXXX									//see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8									$utf8 .= substr($chrs, $c, 2); $c += 1;								} elseif(($ord_chrs_c & 0xF0) == 0xE0) {									// characters U-00000800 - U-0000FFFF, mask 1110XXXX									// see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8									$utf8 .= substr($chrs, $c, 3); $c += 2;								} elseif(($ord_chrs_c & 0xF8) == 0xF0) {									// characters U-00010000 - U-001FFFFF, mask 11110XXX									// see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8									$utf8 .= substr($chrs, $c, 4); $c += 3;								} elseif(($ord_chrs_c & 0xFC) == 0xF8) {									// characters U-00200000 - U-03FFFFFF, mask 111110XX									// see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8									$utf8 .= substr($chrs, $c, 5); $c += 4;								} elseif(($ord_chrs_c & 0xFE) == 0xFC) {									// characters U-04000000 - U-7FFFFFFF, mask 1111110X									// see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8									$utf8 .= substr($chrs, $c, 6); $c += 5;								}								break;						}					}					return $utf8;				} elseif (preg_match('/^\[.*\]$/s', $str) || preg_match('/^\{.*\}$/s', $str)) {					// array, or object notation					if ($str{0} == '[') {						$stk = array(JSON_IN_ARR);						$arr = array();					} else {						if ($this->use == JSON_LOOSE_TYPE) {							$stk = array(JSON_IN_OBJ);							$obj = array();						} else {							$stk = array(JSON_IN_OBJ);							$obj = new stdClass();						}					}					array_push($stk, array('what'  => JSON_SLICE,					'where' => 0,					'delim' => false));					$chrs = substr($str, 1, -1);					$chrs = $this->reduce_string($chrs);					if ($chrs == '') {						if (reset($stk) == JSON_IN_ARR) {							return $arr;						} else {							return $obj;						}					}					//print("\nparsing {$chrs}\n");					$strlen_chrs = strlen($chrs);					for ($c = 0; $c <= $strlen_chrs; ++$c) {						$top = end($stk);						$substr_chrs_c_2 = substr($chrs, $c, 2);						if (($c == $strlen_chrs) || (($chrs{$c} == ',') && ($top['what'] == JSON_SLICE))) {							// found a comma that is not inside a string, array, etc.,							// OR we've reached the end of the character list							$slice = substr($chrs, $top['where'], ($c - $top['where']));							array_push($stk, array('what' => JSON_SLICE, 'where' => ($c + 1), 'delim' => false));							//print("Found split at {$c}: ".substr($chrs, $top['where'], (1 + $c - $top['where']))."\n");							if (reset($stk) == JSON_IN_ARR) {								// we are in an array, so just push an element onto the stack								array_push($arr, $this->decode($slice));							} elseif (reset($stk) == JSON_IN_OBJ) {								// we are in an object, so figure								// out the property name and set an								// element in an associative array,								// for now								if (preg_match('/^\s*(["\'].*[^\\\]["\'])\s*:\s*(\S.*),?$/Uis', $slice, $parts)) {									// "name":value pair									$key = $this->decode($parts[1]);									$val = $this->decode($parts[2]);									if ($this->use == JSON_LOOSE_TYPE) {										$obj[$key] = $val;									} else {										$obj->$key = $val;									}								} elseif (preg_match('/^\s*(\w+)\s*:\s*(\S.*),?$/Uis', $slice, $parts)) {									// name:value pair, where name is unquoted									$key = $parts[1];									$val = $this->decode($parts[2]);									if ($this->use == JSON_LOOSE_TYPE) {										$obj[$key] = $val;									} else {										$obj->$key = $val;									}								}							}						} elseif ((($chrs{$c} == '"') || ($chrs{$c} == "'")) &&						in_array($top['what'], array(JSON_SLICE, JSON_IN_ARR, JSON_IN_OBJ))) {							// found a quote, and we are not inside a string							array_push($stk, array('what' => JSON_IN_STR, 'where' => $c, 'delim' => $chrs{$c}));							//print("Found start of string at {$c}\n");						} elseif (($chrs{$c} == $top['delim']) &&						($top['what'] == JSON_IN_STR) &&						(($chrs{$c - 1} != "\\") ||						($chrs{$c - 1} == "\\" && $chrs{$c - 2} == "\\"))) {							// found a quote, we're in a string, and it's not escaped							array_pop($stk);							//print("Found end of string at {$c}: ".substr($chrs, $top['where'], (1 + 1 + $c - $top['where']))."\n");						} elseif (($chrs{$c} == '[') &&						in_array($top['what'], array(JSON_SLICE, JSON_IN_ARR, JSON_IN_OBJ))) {							// found a left-bracket, and we are in an array, object, or slice							array_push($stk, array('what' => JSON_IN_ARR, 'where' => $c, 'delim' => false));							//print("Found start of array at {$c}\n");						} elseif (($chrs{$c} == ']') && ($top['what'] == JSON_IN_ARR)) {							// found a right-bracket, and we're in an array							array_pop($stk);							//print("Found end of array at {$c}: ".substr($chrs, $top['where'], (1 + $c - $top['where']))."\n");						} elseif (($chrs{$c} == '{') &&						in_array($top['what'], array(JSON_SLICE, JSON_IN_ARR, JSON_IN_OBJ))) {							// found a left-brace, and we are in an array, object, or slice							array_push($stk, array('what' => JSON_IN_OBJ, 'where' => $c, 'delim' => false));							//print("Found start of object at {$c}\n");						} elseif (($chrs{$c} == '}') && ($top['what'] == JSON_IN_OBJ)) {							// found a right-brace, and we're in an object							array_pop($stk);							//print("Found end of object at {$c}: ".substr($chrs, $top['where'], (1 + $c - $top['where']))."\n");						} elseif (($substr_chrs_c_2 == '/*') &&						in_array($top['what'], array(JSON_SLICE, JSON_IN_ARR, JSON_IN_OBJ))) {							// found a comment start, and we are in an array, object, or slice							array_push($stk, array('what' => JSON_IN_CMT, 'where' => $c, 'delim' => false));							$c++;							//print("Found start of comment at {$c}\n");						} elseif (($substr_chrs_c_2 == '*/') && ($top['what'] == JSON_IN_CMT)) {							// found a comment end, and we're in one now							array_pop($stk);							$c++;							for ($i = $top['where']; $i <= $c; ++$i)							$chrs = substr_replace($chrs, ' ', $i, 1);							//print("Found end of comment at {$c}: ".substr($chrs, $top['where'], (1 + $c - $top['where']))."\n");						}					}					if (reset($stk) == JSON_IN_ARR) {						return $arr;					} elseif (reset($stk) == JSON_IN_OBJ) {						return $obj;					}				}		}	}	/**    * decodes a JSON string into appropriate variable; alias for decode()    */	function dec($var)	{		return $this->decode($var);	}}?>